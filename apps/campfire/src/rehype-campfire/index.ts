import { visit } from 'unist-util-visit'
import type { Root } from 'hast'

interface TextNode {
  type: 'text'
  value: string
}

interface ElementNode {
  type: 'element'
  tagName: string
  properties: Record<string, any>
  children: TextNode[]
}

type ReplacementNode = TextNode | ElementNode

/**
 * rehypeCampfire is a rehype plugin that transforms Harlowe-style Twine links ([[...]] syntax)
 * in a HAST (Hypertext Abstract Syntax Tree) into button elements that update
 * the current passage when clicked.
 *
 * This plugin parses text nodes for Twine link patterns, supporting both display text and target passage
 * (e.g., [[Go->Passage]] or [[Passage<-Go]]), and replaces them with interactive
 * buttons that set the passage via its name or pid.
 *
 * @returns {(tree: Root) => void} A transformer function for rehype that mutates the HAST tree in place.
 *
 * @example
 * import rehypeCampfire from '...';
 * import { unified } from 'unified';
 * import rehypeParse from 'rehype-parse';
 *
 * const processor = unified()
 *   .use(rehypeParse, { fragment: true })
 *   .use(rehypeCampfire);
 *
 * const tree = processor.parse('<p>[[Go->Passage]]</p>');
 * const transformed = processor.runSync(tree);
 * // The link will be converted to a button element
 */
export default function rehypeCampfire(): (tree: Root) => void {
  // Matches Harlowe-style links [[...]]
  const linkRegex = /\[\[([^\]]+?)]]/g

  function parseLink(raw: string): { text: string; target: string } {
    const right = raw.indexOf('->')
    const left = raw.indexOf('<-')
    if (right !== -1) {
      return {
        text: raw.slice(0, right).trim(),
        target: raw.slice(right + 2).trim()
      }
    }
    if (left !== -1) {
      return {
        text: raw.slice(left + 2).trim(),
        target: raw.slice(0, left).trim()
      }
    }
    const trimmed = raw.trim()
    return { text: trimmed, target: trimmed }
  }

  /**
   * Determines if the given node is a whitespace-only text node.
   */
  const isWhitespace = (node: any): node is TextNode =>
    node.type === 'text' && !/\S/.test(node.value)

  /**
   * Checks if a node is a LinkButton element generated by this plugin.
   */
  const isLinkButton = (node: any): node is ElementNode =>
    node.type === 'element' &&
    node.tagName === 'button' &&
    Array.isArray(node.properties?.className) &&
    node.properties.className.includes('campfire-link')

  /**
   * Determines if a node is a directive element that should be unwrapped
   * from surrounding paragraph tags.
   */
  const isDirectiveElement = (node: any): node is ElementNode =>
    isLinkButton(node) ||
    (node.type === 'element' &&
      (node.tagName === 'if' ||
        node.tagName === 'else' ||
        node.tagName === 'show' ||
        node.tagName === 'option'))

  const transform = (tree: Root): void => {
    /**
     * Parses a directive property such as `content` or `fallback`, removes
     * extraneous paragraph wrappers, and recursively transforms its children.
     */
    const processDirectiveProp = (node: any, key: string): void => {
      const raw = node.properties?.[key]
      if (Array.isArray(raw) || typeof raw === 'string') {
        try {
          const parsed = Array.isArray(raw) ? raw : JSON.parse(raw)
          const flattened: any[] = []
          for (const child of parsed) {
            if (child.type === 'paragraph') {
              flattened.push(
                ...child.children.filter(
                  (c: any) => !(c.type === 'text' && !/\S/.test(c.value))
                )
              )
            } else {
              flattened.push(child)
            }
          }
          const inner: Root = { type: 'root', children: flattened }
          transform(inner)
          node.properties[key] = Array.isArray(raw)
            ? inner.children
            : JSON.stringify(inner.children)
        } catch {
          /* ignore */
        }
      }
    }
    visit(tree, 'text', (node: any, index: number | undefined, parent: any) => {
      if (
        typeof node.value !== 'string' ||
        !parent ||
        !Array.isArray(parent.children) ||
        typeof index !== 'number'
      )
        return
      const value: string = node.value
      let match
      linkRegex.lastIndex = 0
      const replacements: ReplacementNode[] = []
      let lastIndex = 0
      while ((match = linkRegex.exec(value))) {
        const start = match.index ?? 0
        if (start > lastIndex) {
          replacements.push({
            type: 'text',
            value: value.slice(lastIndex, start)
          })
        }
        const { text, target } = parseLink(match[1])
        const props: Record<string, any> = {
          type: 'button',
          className: ['campfire-link']
        }
        if (/^\d+$/.test(target)) {
          props['data-pid'] = target
        } else {
          props['data-name'] = target
        }
        replacements.push({
          type: 'element',
          tagName: 'button',
          properties: props,
          children: [{ type: 'text', value: text }]
        })
        lastIndex = start + match[0].length
      }
      if (replacements.length) {
        if (lastIndex < value.length) {
          replacements.push({ type: 'text', value: value.slice(lastIndex) })
        }
        parent.children.splice(index, 1, ...replacements)
      }
    })

    visit(
      tree,
      'element',
      (node: any, index: number | undefined, parent: any) => {
        processDirectiveProp(node, 'content')
        processDirectiveProp(node, 'fallback')

        if (node.tagName === 'select' && Array.isArray(node.children)) {
          const key =
            typeof node.properties?.stateKey === 'string'
              ? node.properties.stateKey
              : ''
          const rebuilt: any[] = []
          for (const child of node.children) {
            if (isWhitespace(child)) continue
            if (child.type === 'element' && child.tagName === 'p') {
              const inner = child.children.filter((c: any) => !isWhitespace(c))
              if (
                inner.length === 1 &&
                inner[0].type === 'text' &&
                inner[0].value.trim() === key
              ) {
                continue
              }
              rebuilt.push(...inner)
              continue
            }
            rebuilt.push(child)
          }
          node.children = rebuilt
          return
        }

        if (
          node.tagName !== 'p' ||
          !parent ||
          !Array.isArray(parent.children) ||
          typeof index !== 'number'
        )
          return
        const children = node.children.filter(
          (child: any) => !isWhitespace(child)
        )
        if (children.length && children.every(isDirectiveElement)) {
          parent.children.splice(index, 1, ...children)
        }
      }
    )
  }

  return transform
}
