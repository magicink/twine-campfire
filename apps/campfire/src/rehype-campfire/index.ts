import { visit } from 'unist-util-visit'
import type { Root, Text, Element } from 'hast'
import { isWhitespaceText } from '@campfire/utils/nodePredicates'

type ReplacementNode = Text | Element

/**
 * rehypeCampfire is a rehype plugin that transforms Harlowe-style Twine links ([[...]] syntax)
 * in a HAST (Hypertext Abstract Syntax Tree) into button elements that update
 * the current passage when clicked.
 *
 * This plugin parses text nodes for Twine link patterns, supporting both display text and target passage
 * (e.g., [[Go->Passage]] or [[Passage<-Go]]), and replaces them with interactive
 * buttons that set the passage via its name or pid.
 *
 * @returns {(tree: Root) => void} A transformer function for rehype that mutates the HAST tree in place.
 *
 * @example
 * import rehypeCampfire from '...';
 * import { unified } from 'unified';
 * import rehypeParse from 'rehype-parse';
 *
 * const processor = unified()
 *   .use(rehypeParse, { fragment: true })
 *   .use(rehypeCampfire);
 *
 * const tree = processor.parse('<p>[[Go->Passage]]</p>');
 * const transformed = processor.runSync(tree);
 * // The link will be converted to a button element
 */
export default function rehypeCampfire(): (tree: Root) => void {
  // Matches Harlowe-style links [[...]]
  const linkRegex = /\[\[([^\]]+?)]]/g

  function parseLink(raw: string): { text: string; target: string } {
    const right = raw.indexOf('->')
    const left = raw.indexOf('<-')
    if (right !== -1) {
      return {
        text: raw.slice(0, right).trim(),
        target: raw.slice(right + 2).trim()
      }
    }
    if (left !== -1) {
      return {
        text: raw.slice(left + 2).trim(),
        target: raw.slice(0, left).trim()
      }
    }
    const trimmed = raw.trim()
    return { text: trimmed, target: trimmed }
  }

  /**
   * Checks if a node is a LinkButton element generated by this plugin.
   */
  const isLinkButton = (node: any): node is Element =>
    node.type === 'element' &&
    node.tagName === 'button' &&
    Array.isArray(node.properties?.className) &&
    node.properties.className.includes('campfire-link')

  /**
   * Determines if a node is a directive element that should be unwrapped
   * from surrounding paragraph tags.
   */
  const isDirectiveElement = (node: any): node is Element =>
    isLinkButton(node) ||
    (node.type === 'element' &&
      (node.tagName === 'if' ||
        node.tagName === 'show' ||
        node.tagName === 'option' ||
        node.tagName === 'input' ||
        node.tagName === 'checkbox' ||
        node.tagName === 'radio'))

  const transform = (tree: Root): void => {
    /**
     * Parses a directive property such as `content` or `fallback`, removes
     * extraneous paragraph wrappers, and recursively transforms its children.
     */
    const processDirectiveProp = (node: any, key: string): void => {
      const raw = node.properties?.[key]
      if (Array.isArray(raw) || typeof raw === 'string') {
        try {
          const parsed = Array.isArray(raw) ? raw : JSON.parse(raw)
          const flattened: any[] = []
          for (const child of parsed) {
            if (child.type === 'paragraph') {
              flattened.push(
                ...child.children.filter((c: any) => !isWhitespaceText(c))
              )
            } else {
              flattened.push(child)
            }
          }
          const inner: Root = { type: 'root', children: flattened }
          transform(inner)
          node.properties[key] = Array.isArray(raw)
            ? inner.children
            : JSON.stringify(inner.children)
        } catch {
          /* ignore */
        }
      }
    }
    visit(
      tree,
      'text',
      (node: Text, index: number | undefined, parent: any) => {
        if (
          typeof node.value !== 'string' ||
          !parent ||
          !Array.isArray(parent.children) ||
          typeof index !== 'number'
        )
          return
        const value: string = node.value
        let match
        linkRegex.lastIndex = 0
        const replacements: ReplacementNode[] = []
        let lastIndex = 0
        while ((match = linkRegex.exec(value))) {
          const start = match.index ?? 0
          if (start > lastIndex) {
            replacements.push({
              type: 'text',
              value: value.slice(lastIndex, start)
            } as Text)
          }
          const { text, target } = parseLink(match[1])
          const props: Element['properties'] = {
            type: 'button',
            className: ['campfire-link']
          }
          if (/^\d+$/.test(target)) {
            props['data-pid'] = target
          } else {
            props['data-name'] = target
          }
          replacements.push({
            type: 'element',
            tagName: 'button',
            properties: props,
            children: [{ type: 'text', value: text } as Text]
          })
          lastIndex = start + match[0].length
        }
        if (replacements.length) {
          if (lastIndex < value.length) {
            replacements.push({
              type: 'text',
              value: value.slice(lastIndex)
            } as Text)
          }
          parent.children.splice(index, 1, ...replacements)
        }
      }
    )

    visit(
      tree,
      'element',
      (node: Element, index: number | undefined, parent: any) => {
        processDirectiveProp(node, 'content')
        processDirectiveProp(node, 'fallback')

        if (node.tagName === 'select' && Array.isArray(node.children)) {
          const key =
            typeof node.properties?.stateKey === 'string'
              ? node.properties.stateKey
              : ''
          const rebuilt: any[] = []
          for (const child of node.children) {
            if (isWhitespaceText(child)) continue
            if (child.type === 'element' && child.tagName === 'p') {
              const inner = child.children.filter(
                (c: any) => !isWhitespaceText(c)
              )
              if (
                inner.length === 1 &&
                inner[0].type === 'text' &&
                inner[0].value.trim() === key
              ) {
                continue
              }
              rebuilt.push(...inner)
              continue
            }
            rebuilt.push(child)
          }
          node.children = rebuilt
          return
        }

        if (
          node.tagName !== 'p' ||
          !parent ||
          !Array.isArray(parent.children) ||
          typeof index !== 'number'
        )
          return
        const children = node.children.filter(
          (child: any) => !isWhitespaceText(child)
        )
        if (children.length && children.every(isDirectiveElement)) {
          parent.children.splice(index, 1, ...children)
        }
      }
    )
  }

  return transform
}
